# -*- coding: utf-8 -*-
"""breat_cancer_ml

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cjofLDCyfmlnP6K9aRZs8pl4dxByxbLy
"""

import sklearn.datasets
import numpy as np

breast_cancer=sklearn.datasets.load_breast_cancer()

X=breast_cancer.data
Y=breast_cancer.target

print(X)
print(Y)

print(X.shape)

import pandas as pd

data =pd.DataFrame(breast_cancer.data , columns=breast_cancer.feature_names)

data['class']=breast_cancer.target

data.head()

data.shape

"""#train and test"""

from sklearn.model_selection import train_test_split

X=data.drop('class',axis=1)
Y=data['class']

type(X)

X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.2)

X_train
Y_train

print(X.shape,X_train.shape,X_test.shape)

X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.2,stratify=Y,random_state=1)

import matplotlib.pyplot as plt

plt.plot(X_train.T,'*')
plt.xticks(rotation='vertical')
plt.show()

X_binarised_3_train=X_train['mean area'].map(lambda x:0 if x<1000 else 1)

plt.plot(X_binarised_3_train,'*')

X_binarised_train=X_train.apply(pd.cut,bins=2,labels=[0,1])

plt.plot(X_binarised_train.T,'*')
plt.xticks(rotation='vertical')
plt.show()

X_binarised_test=X_test.apply(pd.cut,bins=2,labels=[0,1])
X_binarised_train=X_train.apply(pd.cut,bins=2,labels=[0,1])
print(type(X_binarised_train))
print( type(X_binarised_test))

plt.plot(X_binarised_test.T,'*')
plt.xticks(rotation='vertical')
plt.show()

X_binarised_test=X_binarised_test.values  
X_binarised_train=X_binarised_train.values

print(type(X_binarised_train))
print( type(X_binarised_test))

X_binarised_test=X_test.apply(pd.cut,bins=2,labels=[1,0])
X_binarised_train=X_train.apply(pd.cut,bins=2,labels=[1,0])
print(type(X_binarised_train))
print( type(X_binarised_test))

X_binarised_test=X_binarised_test.values  
X_binarised_train=X_binarised_train.values

b=3
i=100
if(np.sum(X_binarised_train[i, :])>=b):
  print("malignant")
else:
  print("benign")  

if(Y_train[i]==1):
  print("malignant")  
else:
  print("benign")

b=0
y_pred_train=[]
accurate_rows=0
for x ,y in zip(X_binarised_train,Y_train):
  y_pred=(np.sum(x)>=b)
  y_pred_train.append(y_pred)
  accurate_rows+=(y==y_pred)
print(accurate_rows,accurate_rows/X_binarised_train.shape[0])

for b in range(X_binarised_train.shape[1]+1):
  y_pred_train=[]
  accurate_rows=0
  for x ,y in zip(X_binarised_train,Y_train):
    y_pred=(np.sum(x)>=b)
    y_pred_train.append(y_pred)
    accurate_rows+=(y==y_pred)
  print(b,accurate_rows/X_binarised_train.shape[0])

from sklearn.metrics import accuracy_score

b=28

y_pred_test=[]
# accurate_rows=0
for x  in X_binarised_test :
  y_pred=(np.sum(x)>=b)
  y_pred_test.append(y_pred)
accuracy=accuracy_score(y_pred_test,Y_test)  
  # accurate_rows+=(y==y_pred)
print(b,accuracy*100)

class MpNeuron:

  def __init__(self):
    self.b=None
  def model(self,x):
    return (sum(x)>=self.b)
  def predict(self,X):
    Y=[]
    for x in X:
      result=self.model(x)
      Y.append(result)
    return np.array(Y)  
  def fit(self,X,Y):
    accuracy={}
    for b in range(X.shape[1]+1):
      self.b=b
      Y_pred=self.predict(X)
      accuracy[b]=accuracy_score(Y_pred,Y)
    best_b=max(accuracy, key=accuracy.get)
    self.b=best_b
    print('optimal value of b ', best_b)
    print('highest accuracy ', accuracy[best_b])

mp_neuron=MpNeuron()
mp_neuron.fit(X_binarised_train,Y_train)

Y_test_pred=mp_neuron.predict(X_binarised_test)
accuracy_score(Y_test_pred,Y_test)

"""#Perceptron model"""

class Perceptron:

  def __init__(self):
    self.b=None
    self.w=None

  def model(self,x):
    return 1 if(np.dot(x,self.w)>=self.b) else 0

  def predict(self,X):
    Y=[]
    for x in X:
      result=self.model(x)
      Y.append(result)
    return np.array(Y)  

  def fit(self,X,Y,epochs=1,lr=1):
    self.w=np.ones(X.shape[1])
    self.b=0
    accuracy = {}
    max_accuracy=0
    wt_matrix=[]
    for i in range(epochs):   
      for x,y in zip(X,Y):
        y_pred=self.model(x)
        if y==1 and y_pred==0:
          self.w=self.w+lr*x
          self.b=self.b+lr*1
        elif y==0 and y_pred==1:
          self.w=self.w-lr*x
          self.b=self.b-lr*1  
      wt_matrix.append(self.w)
      accuracy[i]=accuracy_score(self.predict(X),Y)
      if(accuracy[i]>max_accuracy):
        max_accuracy=accuracy[i]
        checkptw=self.w
        checkptb=self.b

    self.w=checkptw
    self.b=checkptb      
    
    print(max_accuracy)

    return wt_matrix
    # accuracy=accuracy.values
    # plt.plot(accuracy.values())      
    # plt.show()

perceptron=Perceptron()
X_train=X_train.values
X_test=X_test.values

Y_train=Y_train.values
Y_test=Y_test.values

wt_matrix=perceptron.fit(X_train,Y_train,1000,0.001)

# plt.plot(perceptron.fit.accuracy)
# plt.show()
# wt_matrix[-1,:]

wt_matrix=np.asarray(wt_matrix)

print(wt_matrix.shape)
# type(wt_matrix)

plt.plot(wt_matrix[-1,:])
plt.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from matplotlib import animation, rc
from IPython.display import HTML

fig, ax = plt.subplots()

ax.set_xlim(( 0, wt_matrix.shape[1]))
ax.set_ylim((-10000, 25000))

line, = ax.plot([], [], lw=2)

def animate(i):
    x = list(range(wt_matrix.shape[1]))
    y = wt_matrix[i,:]
    line.set_data(x, y)
    return (line,)

anim = animation.FuncAnimation(fig, animate, 
                               frames=100, interval=20, 
                               blit=True)

HTML(anim.to_html5_video())